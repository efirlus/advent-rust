use std::collections::HashSet;

struct 안테나 {
    // 가로, 세로
    위치: (i32, i32),
    주파수: char,
}

impl Default for 안테나 {
    fn default() -> Self {
        Self{위치: (0, 0), 주파수: '.'}
    }
}


pub fn 이미테이션_미디오커_초콜렛(입력: &str) -> usize {
    let mut 맵_크기:(i32, i32) = (0, 0);
    let 안테나들:Vec<안테나> = 입력.lines().enumerate()
        .inspect(|(세로, 줄)| {
            맵_크기.0 = 줄.len() as i32;
            맵_크기.1 = *세로 as i32;
        })
        .flat_map(|(세로, 줄)| {
            줄.chars().enumerate()
                .filter(|(_, 글자)| *글자 != '.')
                .map(move |(가로, 주파수)| 안테나 {
                        위치:(가로 as i32, 세로 as i32),
                        주파수,
                    })
        }).collect();

    let mut 주파수_목록:HashSet<char> = HashSet::new();
    안테나들.iter().for_each(|안테나| { 주파수_목록.insert(안테나.주파수); });

    let mut 공명_극대화_지점:HashSet<(i32, i32)> = HashSet::new();
    
    for 주파수 in 주파수_목록 {
        // print!("{} 주파수 대역의 안테나는 ", 주파수);
        let 이번_계산_대상:Vec<&안테나> = 안테나들.iter()
            .filter(|안테나| 안테나.주파수 == 주파수)
            .to_owned()
            .collect();
        /* 이번_계산_대상.iter().for_each(|안테나| {
            print!("{:?}, ", 안테나.위치)
        }); */
        // print!("에 있어요!!\n");
        공명_극대화_지점 = 초콜렛이_너무_먹고싶잖아(이번_계산_대상, 공명_극대화_지점, 맵_크기);
    }

    // println!("그리하여 공명지점은 총 {} 곳 이랍니다~~", 공명_극대화_지점.len());

    return 공명_극대화_지점.len();
}

fn 가능한_조합_찾기(안테나_개수:usize) -> HashSet<(usize, usize)> {
    let mut 가능한_조합:HashSet<(usize, usize)> = HashSet::new();
    for 앞수 in 0..안테나_개수 {
        for 뒷수 in 0..안테나_개수 {
            if 뒷수 <= 앞수 {
                continue;
            } else {
                가능한_조합.insert((앞수, 뒷수));
            }
        }
    }
    // println!("이론상 가능한 조합은 {:?}\n총 {} 가지가 있네요", 가능한_조합, 가능한_조합.len());
    return 가능한_조합;
}

fn 초콜렛이_먹고싶은데(이번_계산_대상:Vec<&안테나>, mut 공명_극대화_지점:HashSet<(i32, i32)>, 맵_크기:(i32, i32)) -> HashSet<(i32, i32)>{
    let 가능한_조합 = 가능한_조합_찾기(이번_계산_대상.len());
    
    가능한_조합.iter().for_each(|(앞안테나, 뒤안테나)| {
        let 앞_안테나_위치 = (이번_계산_대상[*앞안테나].위치.0, 이번_계산_대상[*앞안테나].위치.1);
        let 뒤_안테나_위치 = (이번_계산_대상[*뒤안테나].위치.0, 이번_계산_대상[*뒤안테나].위치.1);

        let 안테나_간_거리 = (앞_안테나_위치.0 - 뒤_안테나_위치.0, 앞_안테나_위치.1 - 뒤_안테나_위치.1) ;
        
        // print!("{:?}와 {:?}가 ", 앞_안테나_위치, 뒤_안테나_위치);

        if 앞_안테나_위치.0 + 안테나_간_거리.0 >= 0 &&
            앞_안테나_위치.1 + 안테나_간_거리.1 >= 0 && 
            앞_안테나_위치.0 + 안테나_간_거리.0 < 맵_크기.0 &&
            앞_안테나_위치.1 + 안테나_간_거리.1 <= 맵_크기.1 {
                /* print!("{:?} ", 
                    (앞_안테나_위치.0 + 안테나_간_거리.0, 앞_안테나_위치.1 + 안테나_간_거리.1)
                ); */
                
                공명_극대화_지점.insert((앞_안테나_위치.0 + 안테나_간_거리.0, 앞_안테나_위치.1 + 안테나_간_거리.1));
        } 
        if 뒤_안테나_위치.0 - 안테나_간_거리.0 >= 0 &&
            뒤_안테나_위치.1 - 안테나_간_거리.1 >= 0 &&
            뒤_안테나_위치.0 - 안테나_간_거리.0 < 맵_크기.0 &&
            뒤_안테나_위치.1 - 안테나_간_거리.1 <= 맵_크기.1 {
                /* print!("{:?} ", 
                    (뒤_안테나_위치.0 - 안테나_간_거리.0, 뒤_안테나_위치.1 - 안테나_간_거리.1)
                ); */
                공명_극대화_지점.insert((뒤_안테나_위치.0 - 안테나_간_거리.0, 뒤_안테나_위치.1 - 안테나_간_거리.1));
        }
        // print!("에 공명을 일으키고 있어요!!\n")
    });

    return 공명_극대화_지점;
}

fn 초콜렛이_너무_먹고싶잖아(이번_계산_대상:Vec<&안테나>, mut 공명_극대화_지점:HashSet<(i32, i32)>, 맵_크기:(i32, i32)) -> HashSet<(i32, i32)>{
    let 가능한_조합 = 가능한_조합_찾기(이번_계산_대상.len());
    
    가능한_조합.iter().for_each(|(앞안테나, 뒤안테나)| {
        let 앞_안테나_위치 = (이번_계산_대상[*앞안테나].위치.0, 이번_계산_대상[*앞안테나].위치.1);
        let 뒤_안테나_위치 = (이번_계산_대상[*뒤안테나].위치.0, 이번_계산_대상[*뒤안테나].위치.1);
        공명_극대화_지점.insert(앞_안테나_위치);
        공명_극대화_지점.insert(뒤_안테나_위치);

        let 안테나_간_거리 = (앞_안테나_위치.0 - 뒤_안테나_위치.0, 앞_안테나_위치.1 - 뒤_안테나_위치.1) ;
        
        // print!("{:?}와 {:?}는 서로 {:?} 만큼 떨어져 있어요~\n", 앞_안테나_위치, 뒤_안테나_위치, 안테나_간_거리);
        let mut 배음 = 1;
        // print!("앞쪽 안테나는");
        'first: loop {
            // print!(", {}배 위치의 ", 배음);
            if 앞_안테나_위치.0 + (배음 * 안테나_간_거리.0) >= 0 &&
                앞_안테나_위치.1 + (배음 * 안테나_간_거리.1) >= 0 && 
                앞_안테나_위치.0 + (배음 * 안테나_간_거리.0) < 맵_크기.0 &&
                앞_안테나_위치.1 + (배음 * 안테나_간_거리.1) <= 맵_크기.1 {
                    /* print!("{:?} ", 
                        (앞_안테나_위치.0 + (배음 * 안테나_간_거리.0), 앞_안테나_위치.1 + (배음 * 안테나_간_거리.1))
                    ); */
                
                    공명_극대화_지점.insert((앞_안테나_위치.0 + (배음 * 안테나_간_거리.0), 앞_안테나_위치.1 + (배음 * 안테나_간_거리.1)));
            } else {
                break 'first;
            }
            배음+=1;
        }
        배음 = 1;
        // print!("뒤쪽 안테나는");
        'last: loop {
            // print!(", {}배 위치의 ", 배음);
            if 뒤_안테나_위치.0 - (배음 * 안테나_간_거리.0) >= 0 &&
                뒤_안테나_위치.1 - (배음 * 안테나_간_거리.1) >= 0 && 
                뒤_안테나_위치.0 - (배음 * 안테나_간_거리.0) < 맵_크기.0 &&
                뒤_안테나_위치.1 - (배음 * 안테나_간_거리.1) <= 맵_크기.1 {
                    /* print!("{:?} ", 
                        (뒤_안테나_위치.0 - (배음 * 안테나_간_거리.0), 뒤_안테나_위치.1 - (배음 * 안테나_간_거리.1))
                    ); */
                    
                    공명_극대화_지점.insert((뒤_안테나_위치.0 - (배음 * 안테나_간_거리.0), 뒤_안테나_위치.1 - (배음 * 안테나_간_거리.1)));
            } else {
                break 'last;
            }
            배음+=1;
        }
        
        // print!("에 공명을 일으키고 있어요!!\n")
    });

    return 공명_극대화_지점;
}



pub fn part2(입력: &str) -> i32 {
    todo!("Implement part 2")
}

#[cfg(test)]
mod tests {
    use super::*;

    const 예문: &str = r#"............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............"#;

    #[test]
    fn test_part1() {
        assert_eq!(이미테이션_미디오커_초콜렛(예문.trim()), 14);
    }

    #[test]
    fn test_part2() {
        assert_eq!(이미테이션_미디오커_초콜렛(예문.trim()), 34);
    }
}