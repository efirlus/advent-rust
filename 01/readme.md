## 첫 번째 날: 어느 역사학자의 우울

수석 역사학회장님은 매 해 크리스마스 썰매 대회를 개최하시던 분이었어요. 그런데 올해 들어 벌써 몇 달 째
아무도 그 분을 본 적도 없다네요! 그나마 마지막으로 그 분 소식을 들은 사람이 말 하길 그 분이 북극점에서 역사적으로 무척이나 중대한 발견을 하러 떠나셨다는데요. 그래서 역사학회의 교수님들은 당신에게 학회장님을 찾는 걸 도와달라고 요청하려고 해요. 학회장님이 가셨을 법한 유력 장소들을 돌아보자는 거지요.

엔목록에 적힌 50곳의 장소를 탐방한 뒤, 별을 하나 씩 체크할 거에요. 학회장님은 **분명히** 그 중 한 곳엔 계실거에요. 이번 크리스마스에도 무사히 썰매 대회가 개최되려면 크리스마스가 오기 전에 역사학자 분들을 도와 50개의 별을 모아야겠지요?

별들은 퍼즐을 풀 때마다 **하나 씩** 모을 수 있답니다. 하루에 2개의 퍼즐을 풀 수 있고, 첫 번째 퍼즐을 풀어야지만 두 번쨰 퍼즐이 보여요! 행운을 빌어

보려고 하는데, 출발도 안했지만 벌써 문제가 터졌네요. 요정 선임역사학자분들이 가져온 체크리스트가 알고보니 **텅 비어**있었어요. 학자분들은 일치단결하여 목록 없이도 뒤져볼 수 있는 가장 유력한 장소를 먼저 확인하기로 한답니다. 바로 학회장님의 사무실이에요.

한바탕 학회장실을 뒤집어 엎은 끝에, 모든 학자분들은 결론을 내릴 수 있었어요. 아, 학회장님은 여기 없네요. 안타깝게도... 그렇지만 요정 대학원생들 몇몇이 역사적으로 무척이나 중대한 장소가 적힌 메모 뭉치를 발견했답니다! 아마 학회장님이 여행을 떠나기 전에 계획을 세우려고 적어놓으셨나봐요. 이 중에 몇 곳을 추리면 되지 않을까요?

학회장님의 메모는 장소 이름으로 적힌 게 아니고 장소 **식별번호**로 적혀 있어요. 이번에야말로 실수하지 않기 위해 학자분들은 두 팀으로 나눠서 각자 메모를 정리해 목록으로 만들었어요.

거의 모든 게 완벽하지만, 한 가지 사소한 문제가 있어요. 두 팀이 만들어주신 목록을 **양 옆에 펼쳐놓고** 보자마자 딱 한 눈에 알 수 있네요. 두 목록이 정말 눈꼽만큼도 비슷한 점이 없다는 거에요. 아무래도 여러분이 목록 정리 작업부터 같이 도와야겠네요.

예시:
```
3    4
4    3
2    5
1    3
3    9
3    3
```

어쩌면, 천운이 따라서 두 목록이 정말 조금만 다를 수도 있어요! 한 번 확인해 봅시다. 두 쌍의 숫자를 정렬해서 서로 얼마나 떨어져 있는지 비교해 보는 거에요. **양 목록**에서 **가장 작은 숫자**를 찾아서 비교해 그 차이를 구하고, 그 다음으로 작은 숫자를 찾아서 그 차이를 구하는 식으로요.

두 숫자의 차이는 우리가 앞으로 가 볼 목적지의 **거리 오차**를 나타낼 거에요. 그러니 이 모든 숫자 간 차이의 합을 **다 더하면** 두 목록이 얼만큼 차이가 나는지 알 수 있겠죠?

위에 보이는 예시를 기준으로 보면 말이에요.
- 왼쪽 목록에서 가장 작은 수는 `1`, 오른쪽 목록에서 가장 작은 수는 `3`이니까 둘 간의 거리는 `2`에요.
- 두번째로 작은 수는 각기 왼쪽 `2`, 오른쪽 `3`이니 차이는 `1`이죠.
- 그 다음으로 작은 수는 두 목록 다 `3`이라서 그 차이는 `0`이고요.
- 다음 수는 각각 `3`, `4`니까 거리는 `1` 차이네요.
- 마지막으로 가장 큰 수는 왼쪽은 `4`인데 오른쪽은 `9`에요. 거리 차이는 `5`가 되겠네요.

이렇게 모든 쌍의 차이를 구해 모두 합한다면 두 목록의 차이를 알 수 있을 거에요. 예시의 경우는 총 `11`만큼 차이나네요!

그럼 이제 학자분들이 주신 목록을 실제로 확인해 볼까요? **두 목록의 차이는 얼마인가요**?


### 기본 전략 구상
1. 기본적으로 가장 중요한 건 일단 외부 파일을 읽는 함수를 짜야된다
2. 그 다음으로 중요한 건 str 에서 '공백문자'를 제거하고 int화하는 것
3. 그 다음은 알고리즘적으론 쉬울거같은데 golang같았으면... Slices.Sort 처리하고 duplicate 한 다음에 양 슬라이스 for 돌려서 - 하고 전부 += 하면 딱 되지...

### 배운 것들
1. 일단 `println!`부터가 이상하다.
    ```
    println!("{:?}", v);
    ```
println은 golang의 printf같은 거고 아무 변수나 다 먹히지 않아서 int, str은 `{}`, Vec(golang의 슬라이스)은 `{:?}`로 처리해야 된다. 참고로 Vec은 <>으로 내용물 속성을 정의해야 하고, str은 길이나 그 외 무언가에 따라 &str이 있다.

2. 생각보다 변수 내 함수 쓰는 법은 간결하다.
    ```
    let mut first_group: Vec<i32> = Vec::new()

    first_group.push(숫자나 변수)
    ```
    이렇게 하면 first_group 벡터에 숫자가 추가된다. append 개념인데, 이 동네 append는 2개의 벡터 중 하나를 쪽 빨아서 다른 벡터에 합치는 거다. 실제로 2번 벡터가 엠티 벡터로 변한다
    이외에도 쓸만 한 벡터 내 함수로 min, max, sort, slice 같은 게 있다

3. 변수의 타입 변환 방법이 왠지 복잡할 느낌이다
    ```
    let num:i32 = "str".parse().unwrap();
    ```
    아직도 이해가 안간다. unwrap이 뭐지?
    에러가 어쩌구 하는데 도통 모르겠네

4. 함수 형태는 좀 더 직관적인 것 같다, 아직은
    ```
    fn historian_hysteria(input: &str) -> (Vec<i32>, Vec<i32>) {
        contents

        return (v1, v2)
    }
    ```

    괄호로 튜플 처리한 거 맘에 드네, golang은 그게 좀 불편했는데

5. for 문에 뭘 집어넣는게 생각보다 곤욕이다
    최근에 golang에도 도입돼 내 머리를 썩이는 장본인 이터레이터가 여긴 기본사항이다
    for에는 이터레이터가 제한부에 들어가야 돼서 그냥 변수를 넣으면 안된다
    start..end 형식을 맞춰야되고, 그래서 `for i in 0..vec1.len()`이 기본적 수식이 된다

6. 변수선언 할 때 mut 안붙이고 let만 쓰면 무조건 constant 처리된다
    계산이 필요하거나 변경될 애들은 무조건 mut을 붙여줘야 된다.


### 당황스러움
1. ㅅㅂ;; 난 당연히 중복이 양쪽 다 있고, 개수가 알아서 맞춰져 있는 줄 알았는데 아니었음, 우측은 605개만 남고 좌측은 1000개까 남음 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 에러 미치는 줄


## 첫 번째 날의 다음 단계

당신의 분석은 결국 두 목록에 제법 엄청난 차이가 있다는 사실만 보여주었어요. 모두의 걱정이 사실로...

지금 보니 학회장님 걱정은 우리만 하나 봅니다.

아무튼 왁자지껄하게 누가 잘못했는지를 두고 난상토론을 벌이는 학자분들은 제쳐두고, 당신은 홀로 목록을 뚫어져라 쳐다보며 심각한 고민을 시작합니다. 그러다가 신기한 사실을 발견했지요. 어쨌건 두 목록 사이에는 제법 많은 숫자가 중복된다는 거에요! 어쩌면 요정 학자님들의 글씨체가 보통이 아니라 우리가 잘못 읽었던 것일 수도 있어요.

당신은 이번에는 일단 왼쪽 메모를 기준으로 놓고 오른쪽 메모에 같은 숫자가 얼마나 나오는지를 헤아려 **유사성**을 검토해보기로 결정했어요. 왼쪽 목록에 나온 숫자가 오른쪽에 몇 번 등장하는지를 세 그 수를 곱한 뒤 그렇게 나온 점수를 전부 더하는 거죠.

아까랑 같은 예시를 놓고 보자면, 유사성 점수는 이런 방식으로 측정할 수 있어요.

```
3    4
4    3
2    5
1    3
3    9
3    3
```

- 왼쪽 목록의 첫 숫자는 `3`이에요. 오른쪽에 총 `3`번 등장하니까 점수는 `9`점이죠.
- 두 번째 수는 `4`인데, 이 수는 `1` 번 등장하네요. 점수는 `4`점.
- 세 번쨰 수인 `2`는 아예 한 번도 등장하지 않아요. 점수는 `0`이 되겠네요.
- 네 번째 수는 `1`이에요. 마찬가지로 오른쪽에는 등장하지 않아요.
- 다섯 번째, 여섯 번쨰 수는 `3`이네요. 아까 위에서 3의 점수는 `9`점이라고 했죠?

따라서 이 점수를 모두 합해보면 예시 목록의 유사성 점수는 `31`점이 나와요.

과연 우리의 진짜 목록의 **유사성 점수**는 몇 점일까요?

### 이차 전략 구상
1. 일단 찾아본 바 iterator.count 함수가 있다. 이걸 쓰려면 vector를 iterator로 변환한 후 거기에 count를 붙이면 된다.
2. 그 다음엔.... 이게 size integer로 나오는 거 같은데, 곱하면 되지 않을까?

### 배운 것들
1. 문제의 iterator
    > [!info] [나무위키](https://namu.wiki/이터레이터)
    > 배열에 순차적으로 접근하고 싶을 때 많이 사용되는 방법이지만, 사실 그보다도 더 큰 이유가 있다. 배열에서의 주소 계산은 '배열의 시작 주소 + 오프셋(각 원소의 메모리 사이즈)'으로 결정되는데, 배열의 요소에 접근할 때는 반드시 이 과정을 거친다. 그런데 순차적으로 접근하는데 그걸 일일이 계산할 필요가 없는 데다가 일일이 계산하려 하면 배열의 끝을 수동으로 검사해야 한다는 문제점도 생긴다. 그래서 반복자라는 개념이 탄생한 것이다.

    일단 대충 이렇다. 내가 이해한 바 대로라면 이터레이터는 어레이, 슬라이스, 벡터 같은 여러 원소의 뭉텡이 종류를 오직 "시작주소"만 남기고 없앤 무언가로 보인다. 이터레이터가 아닌 어레이는 통째로 메모리에 상주해야 하기 때문에 상당한 소비가 있고, 그걸 막기 위해 이터레이터를 쓰는 것 같다.

    아 좀 더 자세한 무언가가 있네. 그냥 뭉텡이가 아니라 "순서"를 가진 뭉텡이를 이터레이터라고 하는 것 같다. 즉 golang의 map이랑 struct는 여러 뭉텡이를 넣어놔도 이터레이터가 아니다. (생각해보니 go map은 `for key, map := range map {}`)이 되긴 하는데...)

2. 타입 문제가 사람을 미치게 만든다
    - 일단 `Vec.iter() == Iter<'_, i32>`
    - 다음 `Iter.filter(|&x| *x == i ) == impl Iterator<Item = &i32>`
        - 핵심은 필터 안에 포인터 상태임, 저 꼬라지 봐 미친 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
    - 그 다음 `Iterator<item>.count() == usize`
    
    이야..... 중구난방이야 ㄹㅇ;;;

3. `use of moved value` 문제
    이 문제는 머리털나고 처음 겪어보는 건데, 메모리 효율을 위해 러스트는 vector같은 걸 카피로 처리하지 않고 다른 언어의 포인터 처리하듯이 막 원본 변수를 쑤셔댄다. 다른 건 몰라도 이터레이터한텐 확실히 그런다

    그러다보니 2번에서 처리한 filter같은 경우, 필터를 먹이면 원본 it가 사라진다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 미친, 이걸 도대체 어떻게 알아 내가

    하여튼 그래서 이런 종류를 돌리려면 for 안에서 매 회차마다 iter를 만들어내고, 필터하고 카운트해야한다

