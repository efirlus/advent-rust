## 첫 번째 날: 어느 역사학자의 우울

### 기본 전략 구상
1. 기본적으로 가장 중요한 건 일단 외부 파일을 읽는 함수를 짜야된다
2. 그 다음으로 중요한 건 str 에서 '공백문자'를 제거하고 int화하는 것
3. 그 다음은 알고리즘적으론 쉬울거같은데 golang같았으면... Slices.Sort 처리하고 duplicate 한 다음에 양 슬라이스 for 돌려서 - 하고 전부 += 하면 딱 되지...

### 배운 것들
1. 일단 `println!`부터가 이상하다.
    ```
    println!("{:?}", v);
    ```
println은 golang의 printf같은 거고 아무 변수나 다 먹히지 않아서 int, str은 `{}`, Vec(golang의 슬라이스)은 `{:?}`로 처리해야 된다. 참고로 Vec은 <>으로 내용물 속성을 정의해야 하고, str은 길이나 그 외 무언가에 따라 &str이 있다.

2. 생각보다 변수 내 함수 쓰는 법은 간결하다.
    ```
    let mut first_group: Vec<i32> = Vec::new()

    first_group.push(숫자나 변수)
    ```
    이렇게 하면 first_group 벡터에 숫자가 추가된다. append 개념인데, 이 동네 append는 2개의 벡터 중 하나를 쪽 빨아서 다른 벡터에 합치는 거다. 실제로 2번 벡터가 엠티 벡터로 변한다
    이외에도 쓸만 한 벡터 내 함수로 min, max, sort, slice 같은 게 있다

3. 변수의 타입 변환 방법이 왠지 복잡할 느낌이다
    ```
    let num:i32 = "str".parse().unwrap();
    ```
    아직도 이해가 안간다. unwrap이 뭐지?
    에러가 어쩌구 하는데 도통 모르겠네

4. 함수 형태는 좀 더 직관적인 것 같다, 아직은
    ```
    fn historian_hysteria(input: &str) -> (Vec<i32>, Vec<i32>) {
        contents

        return (v1, v2)
    }
    ```

    괄호로 튜플 처리한 거 맘에 드네, golang은 그게 좀 불편했는데

5. for 문에 뭘 집어넣는게 생각보다 곤욕이다
    최근에 golang에도 도입돼 내 머리를 썩이는 장본인 이터레이터가 여긴 기본사항이다
    for에는 이터레이터가 제한부에 들어가야 돼서 그냥 변수를 넣으면 안된다
    start..end 형식을 맞춰야되고, 그래서 `for i in 0..vec1.len()`이 기본적 수식이 된다

6. 변수선언 할 때 mut 안붙이고 let만 쓰면 무조건 constant 처리된다
    계산이 필요하거나 변경될 애들은 무조건 mut을 붙여줘야 된다.


### 당황스러움
1. ㅅㅂ;; 난 당연히 중복이 양쪽 다 있고, 개수가 알아서 맞춰져 있는 줄 알았는데 아니었음, 우측은 605개만 남고 좌측은 1000개까 남음 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 에러 미치는 줄


## 첫 번째 날의 다음 단계

### 이차 전략 구상
1. 일단 찾아본 바 iterator.count 함수가 있다. 이걸 쓰려면 vector를 iterator로 변환한 후 거기에 count를 붙이면 된다.
2. 그 다음엔.... 이게 size integer로 나오는 거 같은데, 곱하면 되지 않을까?

### 배운 것들
1. 문제의 iterator
    > [!info] [나무위키](https://namu.wiki/이터레이터)
    > 배열에 순차적으로 접근하고 싶을 때 많이 사용되는 방법이지만, 사실 그보다도 더 큰 이유가 있다. 배열에서의 주소 계산은 '배열의 시작 주소 + 오프셋(각 원소의 메모리 사이즈)'으로 결정되는데, 배열의 요소에 접근할 때는 반드시 이 과정을 거친다. 그런데 순차적으로 접근하는데 그걸 일일이 계산할 필요가 없는 데다가 일일이 계산하려 하면 배열의 끝을 수동으로 검사해야 한다는 문제점도 생긴다. 그래서 반복자라는 개념이 탄생한 것이다.

    일단 대충 이렇다. 내가 이해한 바 대로라면 이터레이터는 어레이, 슬라이스, 벡터 같은 여러 원소의 뭉텡이 종류를 오직 "시작주소"만 남기고 없앤 무언가로 보인다. 이터레이터가 아닌 어레이는 통째로 메모리에 상주해야 하기 때문에 상당한 소비가 있고, 그걸 막기 위해 이터레이터를 쓰는 것 같다.

    아 좀 더 자세한 무언가가 있네. 그냥 뭉텡이가 아니라 "순서"를 가진 뭉텡이를 이터레이터라고 하는 것 같다. 즉 golang의 map이랑 struct는 여러 뭉텡이를 넣어놔도 이터레이터가 아니다. (생각해보니 go map은 `for key, map := range map {}`)이 되긴 하는데...)

2. 타입 문제가 사람을 미치게 만든다
    - 일단 `Vec.iter() == Iter<'_, i32>`
    - 다음 `Iter.filter(|&x| *x == i ) == impl Iterator<Item = &i32>`
        - 핵심은 필터 안에 포인터 상태임, 저 꼬라지 봐 미친 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
    - 그 다음 `Iterator<item>.count() == usize`
    
    이야..... 중구난방이야 ㄹㅇ;;;

3. `use of moved value` 문제
    이 문제는 머리털나고 처음 겪어보는 건데, 메모리 효율을 위해 러스트는 vector같은 걸 카피로 처리하지 않고 다른 언어의 포인터 처리하듯이 막 원본 변수를 쑤셔댄다. 다른 건 몰라도 이터레이터한텐 확실히 그런다

    그러다보니 2번에서 처리한 filter같은 경우, 필터를 먹이면 원본 it가 사라진다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 미친, 이걸 도대체 어떻게 알아 내가

    하여튼 그래서 이런 종류를 돌리려면 for 안에서 매 회차마다 iter를 만들어내고, 필터하고 카운트해야한다

## 다음날을 위한 준비, 치열한 모듈화

### 기본적인 구상
1. 일단 기왕 이렇게 된 거, 한글로 만들자 싶음.
2. 러스트의 기본적인 모듈 임포트 방식이 `use str::module;`이던데, 나는 `use 어쨌건::모듈이름`이 되는 식이지

### 이것까지 ai를 안쓸 필요는 없다
1. 일단 golang이 모듈 관리를 go mod에서 하는 것과 다르게, 러스트는 lib.rs에서 한다. 자기언어컴파일 언어다운 행보.
    하지만 cargo.toml에 lib 경로를 적어야 하는 건 단점, 아니 그건 센스있게 탁 읽어야지...
    현대적인 언어 답게 한글을 기본적으로 지원해준다. 하지만 내 리눅스가 한글을 거지같이 지원하기 때문에, 파일명 정도는 영어로 유지하고 싶었다.
    ```
    #[path = "day01.rs"]
    pub mod 어느_역사학자의_우울;
    ```
    모듈명과 파일명을 다르게 하는 것도 잘 된다. golang의 경우는 이게 `import 한글 as "modulepath"` 처리가 안됐었다
    아주 괜찮은 느낌이 든다

2. 모듈 내에서 함수의 제공은
    어렵지 않았다. 반드시 `pub fn 함수명`을 지키면 된다
