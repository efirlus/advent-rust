## 시작전부터 배운다

### 매일매일 새 문서 만들기가 귀찮아
이건 뭐 크게 기대 안하고 나는 bash 정도나 짜주려니 싶어서 클로드한테 물어봤다
근데 이놈이 rust-script를 짜주는 게 아닌가 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

file write에 대해서 공부할 생각은 없었는데 많은 공부가 됐고
또 배운게 있다

1. if의 반환과 `;`
```rust
    let lib_path = "src/lib.rs";
    let mut lib_content = if Path::new(lib_path).exists() {
        fs::read_to_string(lib_path).unwrap_or(String::new())
    } else {
        String::new()
    };
```
전혀 생각 못했던 `;`에 특수기능이 있다
if else 구문이 = 를 통해 let variable에 쑤셔박아지는 것도 신기한데, 그 리턴값이 ;에 따라 바뀐다

;를 쓰면 - 그 스코프의 최종결과물이 반환된다. 지금같은 경우는 string::new니까 `()`만 반환되는 것
;가 없으면 - 조건이 맞을 때 바로 반환된다. read_to_string이 반환되는 셈 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

2. 테스트 모듈
```rust
#[cfg(test)]
mod tests {
    use super::*;

    const EXAMPLE: &str = r#"1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet"#;

    #[test]
    fn test_part1() {
        assert_eq!(part1(EXAMPLE.trim()), "142");
    }
}
```
이야.... 이런 세상이 있다
개신기하네 진짜, 누르면 테스트가 완료된다. 예문을 main에 넣을 필요가 없네 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ


## 경비 피하기 경기

엊그제 썼던 그 텔레포트 장치를 또 사용해서 이번엔 직접 역사속으로 뛰어들었다.

2018년 5일차에 타임패러독스를 피하기 위해 그렇게 고생했던 북극점 산타복 초호기 연구소에 다시 가게 된 거다. 개발 연구 단계이던 1518년 당시로!
타임패러독스를 막기 위해 누구의 눈에라도 띄이면 안되는게 당연한 와중에, 학자분들은 숨막힐듯한 역사의 격류에 빠져 광분 상태고
하필이면 경비가 하나가 있다.... (역자주:지금 보니 경비 요정 아가씨다)

이 경비를 피하며 학자분들을 안전하게 통솔해야 하는게 이번 과제다

```
....#.....
.........#
..........
..#.......
.......#..
..........
.#..^.....
........#.
#.........
......#...
```

예를 들어 지도는 이렇게 표현할 수 있는데, `^`가 경비다 (꺽쇠의 방향이 바라보는 방향이다)
눈을 피할 수 있는 장애물(박스가 됐건 책상, 연금술 반응로, 등등 뭐가 됐건)은 `#`다

1518년의 경비체계는 몹시 일률적이고도 철저하다.
1. 내 눈 바로 앞에 무엇인가가 있으면 시계방향으로 90도 회전한다
2. 없으면 부딪힐 때 까지 직진한다

첫 예시의 경우, 좌표 (4,0) 지점까지 가서 실패작 산타복 모형 더미에 부딪힌 경비는
90도를 시계방향으로 돌아 좌표 (10,1) '정말 엄청나게 긴 고분자중합체들이 뭉친 덩어리'에 부딪힌다
그 다음엔 아래로 쭉 내려가 (9, 7)에서 부딪히고, (0,7)에 박고를 몇번 하다 보면
(6,9)에 위치한 다용도 용매 저장탱크의 오른쪽을 지나쳐 아래로 내려가는 방향으로 쭉 나가
'맵 밖으로' 벗어나 다른 영역에 들어가게 될 것이다
```
....#.....
.........#
..........
..#.......
.......#..
..........
.#........
........#.
#.........
......#v..
```

이 모든 과정을 역산해 경비 소녀의 첫 시작점부터 탈출점까지를 그릴 수 있다
```
....#.....
....XXXXX#
....X...X.
..#.X...X.
..XXXXX#X.
..X.X.X.X.
.#XXXXXXX.
.XXXXXXX#.
#XXXXXXX..
......#X..
```
예시를 기준으로는 총 41칸을 훑었다
바로 이 숫자, 몇 칸 훑었는지를 구해보자



### 접근법

일단 struct를 짜자, 가로 세로 방향의 3가지 속성을 지닌 '경비'
가로세로만 지닌 '장애물'을 만들자

lines.len이랑 line.chars.len으로 맵 가로세로를 구하고

4방향, 연쇄 `+=`, `-=` 루프를 돌려서 #이 있는 포인트 직전에서 멈추게 하고

한칸 지나갈 때마다 좌표 tuple을 저장하자, 그리고 이걸 전부 Vec으로 한 다음 dedup 한 번 써보자
그리고 나서 len하면 될거같다

### 실행
상상외로 무언가 무난하게 진행되고 있다... 이제 나도 고수?
```rust
입력.lines().enumerate()
        .for_each(|한줄씩| {
            한줄씩.1.chars().enumerate()
                .for_each(|한글자씩| {
                    match 한글자씩.1 {
```
지도_읽기 함수의 아름다운 method stack

물론 사실 개선의 여지가 있을거같긴 해, 특히 경비_메뉴얼 함수는 줄일 수 있을거같은데, 내가 더 많이 배워야지

1. 포인터, borrow, move 개념은 봐도봐도 적응이 안된다 
```rust
'outer: loop {
        if 경비.위치.0 < 0 || 경비.위치.1 < 0 || 경비.위치.0 > 지도_크기.0 || 경비.위치.1 > 지도_크기.1 {
            break 'outer;
        } else if !장애물들.contains(&경비.위치) {
            println!("{:?} : 이 곳엔 아무것도 없어요! {:?}측으로 전진합니다!!", &경비.위치, &경비.방향);
            경비 = 경비_메뉴얼(경비.clone(), "전진");
            let 이번_방문_장소 = 경비.위치.clone();
            방문한_장소.push(이번_방문_장소.clone());
        } else if 장애물들.contains(&경비.위치) {
            println!("{:?} : 아코! 쿵했어요! 90도 회전해서 {:?}측으로 전진합니다!!", &경비.위치, &경비.방향);
            경비 = 경비_메뉴얼(경비, "회전");
            방문한_장소.pop();
            let 이번_방문_장소 = 경비.위치.clone();
            방문한_장소.push(이번_방문_장소.clone());
        }
    }
```
이게 이렇게 clone이 많이 들어가고 포인터가 도배될 일인가...


2. 이해가 안가는 메쏘드 적용방식
아니 왜 vector.sort.dedup은 적용이 안되고

```rust
    let mut 중복_제거 = 방문한_장소.to_vec();
    중복_제거.sort();
    중복_제거.dedup();
```
은 되는거지 이해가 안가네
**이건 아무리 검색해도 이해가 안가서, 설마 3개를 줄로 나눠서 따로 적용하는 건 아니겠지 하고, ai한테 물어봤는데 이거래**
진짜 이해가 안가네 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ



## 파트 2

해결사 노릇을 하도 오래 해서 이젠 전문가가 다 됐다
방금 학자분들이 들고다니던 리모콘을 잠깐 '소유권이전'해서, 학자분들이 재미난 "수ㄹ래ㅐㄱ잡기"를 하는 사이에
실험복 옷장에 숨어서 지난 몇달간의 야간 경비 기록을 모아봤다

차근차근 기록을 살펴본 바, 이 경비 범위가 보통 철저한게 아니라, 아무래도 일반적인 수단으로는 경비원의 눈을 피하기 쉽지 않다

그래서 학자분들을 불러 모아놓고, 타임 패러독스가 발생하지 않는 선에서 장애물을 설치하자고 제안했다

설치할 수 있는 장애물은 단 하나인데, 그 하나로 경비 경로를 무한 순환하게 만들어야 한다

위의 지도를 기준으로 보면

1. 압출식 구텐베르크 인쇄기를 경비 시작지점 왼쪽에 밀어둔다
```
....#.....
....+---+#
....|...|.
..#.|...|.
....|..#|.
....|...|.
.#.O^---+.
........#.
#.........
......#...
```

2. 실험작 산타복 더미를 잔뜩 꺼내놓는다
```
....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
......O.#.
#.........
......#...
```

3. 굴뚝 구멍 침투장비용 원단 실험작이 든 박스를 책상 옆에 뒤집어놓는다
```
....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
.+----+O#.
#+----+...
......#...
```

4. 연금술 레트로인캐뷸레이터를 구석에 진열해둔다 (미국판 무한동력 사기 사건으로 이름높은 그런 기계, 밈)
```
....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
..|...|.#.
#O+---+...
......#...
```

5. 아니면 좀 더 가운데로 당겨둔다
```
....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
....|.|.#.
#..O+-+...
......#...
```

6. 소베린 접착제 탱크를 다용도 용매 저장 탱크 옆으로 끌어둔다
```
....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
.+----++#.
#+----++..
......#O..
```

존나 예문 개웃긴데 하여튼

이 "경우의 수"를 구하자


### 접근법

1. 가장 간단한 법 = 매 포인트마다 하나씩 "인공장애물"을 설치하고, loop을 돌리다가 방문장소 vector가 더 이상 늘어나지 않으면 그 장소에서 1점 추가
    기각, 지금 예로 든거 보니까 full path 루프가 아님

2. 탐색경로에 자체적으로 if contains not push 를 넣고, 탐색 경로 len과 탐색 스탭 enumerate를 별개로 분리해서, en-index가 len의 2배가 되도록 탈출하지 못할 때 브레이크 후 1점 추가
일단 2번으로 해보자


### 실행

2번 방식으로 예문은 간단히 끝났는데... 이게 이렇게 본론이 오래 걸린다고?
아무리 봐도 이게 완성은 됐어, 무조건 답은 나올건데, 너무 오래걸리는게 문제임
이따 누워서 돌리고 적든지 내일 아침에 게임 설치하면서 돌리던지 하자

2. 후보군 압축을 적용함, 130*130이 아니라, **아무것도 없을 때 경비가 갈 수 있는 경로** 만 세기로 함

>> 그렇게 했는데도 3시간 걸림 미친;;;; 이렇게 오래걸릴 일인가 이게 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ



## AI와 복습

이야... 머리가 좋다 확실히
딱 보더니 "**좌표와 방향은 절대 같을 수 없는거 아닌가**" 하네... 듣고 보니 맞는 말 같음
'방문한 장소' 를 모을 때 ((좌표), 방향) 튜플로 모아서, contains... 아니지 이 경우에는 HashSet이라는 걸 쓰면 좋다고 함
HashSet은 기본적으로 go의 map[key]bool하고 유사하게 중복을 받지 않고 순서가 없으며 O-1 알고리즘으로 존재 여부만 추적하는 데이터셋임

이걸 듣고 나니 tovec sort dedup 쓸 필요가 사라짐
굿

